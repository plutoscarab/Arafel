
Maybe data type.

    type Maybe(t) = Nothing | Just(t)

    maybe(default, selector, m) = case m of
        Nothing -> default
        Just(x) -> selector(x)

    fmap(selector, m) = maybe(Nothing, selector, m)


Either data type.

    type Either(t, u) = Left(t) | Right(u)

    either(leftSelector, rightSelector, m) = case m of
        Left(x) -> leftSelector(x)
        Right(x) -> rightSelector(x)

    fmap(selector, m) = either((x) = Left(x), selector, m)


Ordering data type.

    type Ordering = LT | EQ | GT


Tuple functions.

    fst(p) = case p of
        a, b -> a

    snd(p) = case p of
        a, b -> b

Convert a function that takes a pair into a function that takes two separate arguments.

    curry(f) = (a, b) = f((a, b))

Convert a function of two arguments into a function that takes one pair argument.

    uncurry(f) = (p) = case p of
        a, b -> f(a, b)


Lists

    map(f, m) = case m of
        [] -> []
        x:xs -> f(x) : map(f, xs)

    agg(op, zero, list) = case list of
        [] -> zero
        x:xs -> agg(op, op(zero, x), xs)

    aggr(op, zero, list) = case list of
        [] -> zero
        x:xs -> op(x, agg(op, zero, xs))

    sum(list) = agg(`+`, 0, list)

    prod(list) = agg(`*`, 1, list)

    take(n, list) = if (n < 1) then [] else 
        case list of
            [] -> []
            x:xs -> x : take(n - 1, xs)

    takeWhile(pred, list) = case list of
        [] -> []
        x:xs -> if pred(x) then x:takeWhile(pred, xs) else []

    takeUntil(pred, list) = case list of
        [] -> []
        x:xs -> if pred(x) then [] else x:takeUntil(pred, xs)

    skip(n, list) = case list of
        [] -> []
        x:xs -> if n < 1 then [] else x : skip(n - 1, xs)

    skipWhile(pred, list) = case list of
        [] -> []
        x:xs -> if pred(x) then skipWhile(pred, xs) else list

    skipUntil(pred, list) = case list of
        [] -> []
        x:xs -> if pred(x) then list else skipUntil(pred, xs)

    filter(pred, list) = case list of
        [] -> []
        x:xs -> let f = filter(pred, xs) 
            if pred(x) x:f else f

    repeat(x, n) = case of
        n < 1 -> [] 
        else x : repeat(x, n - 1)

    isEmpty(list) = case list of
        [] -> true
        _ -> false

    cycle(list) =
        cycle'(list) = list ++ cycle'(list)
        case list of
            [] -> []
            _ -> cycle'(list)

    tail(list) = case list of
        [] -> []
        x:xs -> xs

    head(list) = case list of
        [] -> Nothing
        x:xs -> Just(x)

    len(list) = agg((n, _) = n + 1, 0, list)

    
Miscellaneous

    id(x) = x

    op 12 fâˆ˜g = (x) = f(g(x))

    flip(f) = (a, b) = f(b, a)

    until(pred, fn) = 
        go(x) = if pred(x) then x else go(fn(x))
        go

    iterate(fn, x) = x:iterate(fn, fn(x))

    not(p) = (b) = ~p(b)



ARAFEL

Arafel is a strict, lazy, statically-typed functional programming language. 
Source files contain comments on non-indented lines and code on indented 
lines. You're reading a valid Arafel source file. Files must be encoded in 
either ASCII or UTF-8.


VALUES

An Arafel program produces values. An Arafel "host" decides what to do with
those values. The default console host just writes them to the console.

Nat values represent natural (non-negative) numbers. They are either 0 or a 
sequence of digits that doesn't start with zero. Digit group separators can 
be used to make it easier to read large numbers. Here are some Nat values:

    0
    500
    1_000_000
    43252003274489856000
    ੨੦੨੨
    𝟞𝟜
    
Those last two values show that you can use decimal digits from scripts other
than arabic numerals.

Dec values represent values with a decimal fraction portion.

    3.1416
    1_000_000.000_000_9


EXPRESSIONS

Expressions use values and operators together to compute a result. Common
operators include +, -, * (for multiplication), and / (for division).

    365 * 24 * 60 * 60

This prints "31536000" which is the number of seconds in a normal year.

Operators can have higher or lower precedence than other operators.
Understanding precendence allows you to avoid using unnecesary parenthesis.
For example, * is higher precedence than +, so these two expressions both
evaluate as -2:

    2 * 5 + 3 * -4
    (2 * 5) + (3 * -4)

You can add parenthesis when necessary to override the operator precedence.
This expression evaluates as 64:

    2 * (5 + 3) * -4

The "power" operator for exponentiation is "**". It is right-associative, so 
these two expressions are equivalent:

    5 ** 4 ** 3 ** 2
    5 ** (4 ** (3 ** 2))

Superscript digits can also be used for exponentiation.

    3² + 4²
    1.05¹²


FUNCTIONS

Functions in Arafel are written like this which returns the square
of a number:

    square(x) = x * x

Functions that you define this way can be used in expressions later in
the program.

    365 * 24 * square(60)
    hypot(3, 4)

There are many built-in functions, such as "sqrt":

    hypot(a, b) = sqrt(a * a + b * b)


LISTS

Empty list.

    []

Finite lists.

    [1]    
    [2, 3]

Integers from four through one-hundred:

    [4..100]

Odd numbers 5 through 99:

    [5, 7..100]

Infinite list 6, 7, 8, etc.

    [6..]

Odd numbers starting with 7:

    [7, 9..]

List by item concatenation.

    1 : 2 : 3 : []
    let L = 4 : 5 : []
    6 : L

List item extraction:

    case L of
        h:tail -> Just(h)
        else Nothing


ARRAYS

    {}
    {1, 2, 3}
    {3+5, 3-5, 3*5, 3/5}
    {{'a', 'b'}, {'c', 'd'}}
    {[1], [1,2], [1,2,3]}

Array pattern matching.

    case arr of
        {} -> "empty"
        {x} -> "one element"
        {x, y} -> "two elements"
        {x, ..} -> "at least one element"
        {x, y, ..} -> "at least two elements"
        {.., x} -> "get last element"
        {.., x, y} -> "get last two elements"
        {x, .., y} -> "get first and last element"
        else "else"

Array element indexing. This returns "3":

    {1, 2, 3, 4} !! 2

This returns "1" because (20 % 4) == 0:

    {1, 2, 3, 4} !! 20

Array views (a.k.a. slicing) attempt using map:

    toArray(map([-2..-1], (i) = {1, 2, 3, 4} !! i))

Syntactic sugar, does not wrap around the ends of the array,
so this returns {3, 4}:

    {1, 2, 3, 4} !! [2..]

Blows up memory:

    toArray([0..])


TAGGED UNIONS 𝑎.𝑘.𝑎. DISCRIMINATED UNIONS 𝑎.𝑘.𝑎. SUM TYPES

Binary tree with data in the leaf nodes:

    type Tree(t) = Leaf(t) | Node(Tree(t), Tree(t))

This defines two different functions for creating trees, one called Leaf
that takes a value and returns a tree with a single leaf node, and one
called Node that returns a tree with two sub-trees.

It also defines a function called Tree that takes a type argument and
returns a type. For example Tree(Int) is a tree of Int values and Tree(Char)
is a tree of Char values. Tree is not a type, but is a function that returns
a type.

Here we create a Tree(Char):

    let x = Node(Leaf('a'), Node(Leaf('b'), Leaf('c')))

This produces the following tree where "*" indicate Nodes:

:     b   c
:      \ /
:   a   *
:    \ /
:     *

To use a union type, we use the "case" function to match with each of the
functions that were used to create the tree. Here's a function to count the
leaf nodes in our tree.

    count(t) = case t of 
        Leaf(_) -> 1 
        Node(left, right) -> count(left) + count(right)

    count(x)

This prints "3" for the tree we created above.


FUNCTIONS AS VALUES, ALSO LAMBDAS 𝑎.𝑘.𝑎. ANONYMOUS FUNCTIONS

Functions are values in and of themselves, and can be passed as arguments to
other functions. Here's a function that accepts a function as input and applies
it to each value in a list to produce a new list.

    map(list, func) = case list of
        [] -> []
        head:tail -> func(head) : map(tail, func)

We can use this to apply our "square" function to each item in the list.

    map([1..5], square)

This produces [1, 4, 9, 16, 25]. We can also supply a function directly in the 
call to map without defining a named function first.

    map([1..5], (x) = x * x)

An unnamed function like this is called a lambda function, after Lambda
calculus.


CUSTOM OPERATORS

Infix operator with precedence 7.

    op 7 list1😀list2 = case list1 of
        [] -> list2
        x:xs -> x : (xs😀list2)

    [1, 2]😀[3, 4, 5]

Infix operator with name instead of symbols.

    op 7 list1 cat list2 = list1 ++ list2

    [1, 2] cat [3, 4, 5]

Custom postfix operator "|>" which returns zero for negative numbers.

    op x|> = if x < 0 then 0 else x

    (-42)|>

Define the double factorial operator. This prints "3715891200". Local function
definition to take advantage of tail recursion.

    op n!! = 
        rec(acc, n) = if n < 2 then acc else rec(acc * n, n - 2)
        if n < 2 then n else rec(n, n - 2)

    20!!

Custom prefix operator "+." which returns 1 more than the argument.

    op +.x = x + 1

    +.364


type Bool = False | True

    type Bool = forall a, a -> a -> a.
    let False = (f:a, t:a) = f
    let True = (f:a, t:a) = t

Note that this swaps the f and t values compared to traditional Church encoding.

case b of  False -> 33  True -> 42  becomes

    b(33, 42)

which prints 33 if b=False or 42 if b=True.

    let not =
        (b:Bool) = b(True, False)

    let and = 
        (left:Bool, right:Bool) = left(left, right)

    let or = 
        (left:Bool, right:Bool) = right(left, right)

    let xor =
        (left:Bool, right:Bool) = left(right, not right)

    let eq =
        (left::Bool, right::Bool) = left(not right, right)

type Maybe(t) = Nothing | Just(t)

    let Nothing = 
        (n, j) = n

    let Just(t) =
        (n, j) = j(t)

type Either(t) = Left(t) | Right(t)

    let Left(t) =
        (l, r) = l(t)

    let Right(t) =
        (l, r) = r(t)

type Tree(t) = Leaf(t) | Node(Tree(t), Tree(t))

    let Leaf(t) =
        (l, n) = l(t)

    let Node(left, right) =
        (l, n) = n(left, right)

type List(t) = Nil | Cons(t, List(t))

    let Nil =
        (n, c) = n

    let Cons(head, tail) =
        (n, c) = c(head, tail)

    let list = Cons(5, Cons(3, Cons(2, Nil)))

    0
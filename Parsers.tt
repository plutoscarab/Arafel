<#@ output extension=".cs" encoding="utf-8" #>
using System.Text;
<#
    Parser("Token", "Rune", "new Rune()");
    Parser("TokenTree", "Token", "new Token(Cursor.Empty, Cursor.Empty)");
#>
<#+
void Parser(string resultType, string cursorType, string endValue)
{
    var ctype = (cursorType == "Rune" ? "" : cursorType) + "Cursor";
    var lctype = cursorType.ToLower();
    var ptype = cursorType + "Parser";
#>

internal sealed partial record <#= ctype #>(IReadOnlyList<<#= cursorType #>> Source, int Offset)
{
    public <#= ctype #>(IList<<#= cursorType #>> source)
    : this((IReadOnlyList<<#= cursorType #>>)source, 0)
    { }

    private <#= ctype #>(<#= ctype #> cursor, int offset)
    : this(cursor.Source, offset)
    { }

    public bool More => Offset < Source.Count;

    public <#= cursorType #> Current => More ? Source[Offset] : <#= endValue #>;

    public static bool operator >(<#= ctype #> a, <#= ctype #> b) => a.Offset > b.Offset;
    
    public static bool operator <(<#= ctype #> a, <#= ctype #> b) => a.Offset < b.Offset;

    public static int operator -(<#= ctype #> a, <#= ctype #> b) => a.Offset - b.Offset;
}

internal partial record <#= resultType #>(<#= ctype #> Start, <#= ctype #> Next)
{
    public readonly List<<#= resultType #>> Children = new();

    public string Production = string.Empty;

    public <#= resultType #>(<#= ctype #> start) : this(start, start.Next()) { }

    public <#= resultType #>(<#= ctype #> start, <#= ctype #> next, IEnumerable<<#= resultType #>> children) 
    : this(start, next) 
    { 
        Children = children.ToList(); 
    }

    public IEnumerable<<#= cursorType #>> <#= cursorType #>s()
    {
        var t = Start;

        while (t.More && t.Offset < Next.Offset)
        {
            yield return t.Current;
            t = t.Next();
        }
    }

    public void Dump(TextWriter writer)
    {
        writer.WriteLine($"Line {Start.Line} Col {Start.Col}");
        Dump(writer, string.Empty);
    }

    private void Dump(TextWriter writer, string indent, bool last = true)
    {
        var branch = last ? "└" : "├";
        var prod = Production;
        if (prod != "") prod += ": ";
        var token = Children.Any() ? "" : string.Join("", <#= cursorType #>s().Select(t => t.ToString()));
        writer.WriteLine($"{indent}{branch}─{prod}{token}");
        indent += last ? "  " : "│ ";
        
        foreach (var (child, i) in Children.Select((c, i) => (c, i)))
        {
            child.Dump(writer, indent, i == Children.Count - 1);
        }
    }
}

internal delegate (<#= resultType #>? Result, <#= ctype #> Next) <#= ptype #>(<#= ctype #> cursor);

internal sealed class <#= cursorType #>Parsers
{
    public static <#= ptype #> Any =
        cursor => (new <#= resultType #>(cursor), cursor.Next());

    public static <#= ptype #> Expect(Predicate<<#= cursorType #>> predicate) =>
        cursor => predicate(cursor.Current) ? (new <#= resultType #>(cursor), cursor.Next()) : (null, cursor);

    public static <#= ptype #> Expect<T>() =>
        Expect(<#= lctype #> => <#= lctype #> is T);

    public static <#= ptype #> Expect(params <#= cursorType #>[] values) =>
        Expect(<#= lctype #> => values.Contains(<#= lctype #>));

    public static <#= ptype #> OneOf(params <#= ptype #>[] parsers) =>
        cursor =>
        {
            foreach (var parser in parsers)
            {
                var (result, next) = parser(cursor);
                if (result is not null) return (result, next);
            }

            return (null, cursor);
        };

    public static <#= ptype #> Seq(params <#= ptype #>[] parsers) =>
        cursor =>
        {
            var start = cursor;
            List<<#= resultType #>> list = new();

            foreach (var parser in parsers)
            {
                var (result, next) = parser(cursor);
                if (result is null) return (null, cursor);

                if (result.Next.Offset > result.Start.Offset) 
                    if (result.Children.Any() && string.IsNullOrEmpty(result.Production))
                        list.AddRange(result.Children);
                    else
                        list.Add(result);

                cursor = next;
            }

            if (list.Count == 1)
                return (list[0], cursor);

            return (new <#= resultType #>(start, cursor, list), cursor);
        };

    public static <#= ptype #> OneOrMore(<#= ptype #> parser) =>
        cursor =>
        {
            var start = cursor;
            List<<#= resultType #>> list = new();
            
            while (true)
            {
                var (result, next) = parser(cursor);
                if (result is null) break;

                if (result.Next.Offset > result.Start.Offset) 
                    if (result.Children.Any() && string.IsNullOrEmpty(result.Production))
                        list.AddRange(result.Children);
                    else
                        list.Add(result);

                cursor = next;
            }
            
            if (cursor.Offset > start.Offset)
            {
                if (list.Count == 1)
                    return (list[0], cursor);
                    
                return (new <#= resultType #>(start, cursor, list), cursor);
            }
                
            return (null, start);
        };

    public static <#= ptype #> ZeroOrMore(<#= ptype #> parser) =>
        cursor =>
        {
            var start = cursor;
            List<<#= resultType #>> list = new();
            
            while (true)
            {
                var (result, next) = parser(cursor);
                if (result is null) break;

                if (result.Next.Offset > result.Start.Offset) 
                    if (result.Children.Any() && string.IsNullOrEmpty(result.Production))
                        list.AddRange(result.Children);
                    else
                        list.Add(result);

                cursor = next;
            }
            
            if (cursor.Offset > start.Offset)
            {
                if (list.Count == 1)
                    return (list[0], cursor);
                    
                return (new <#= resultType #>(start, cursor, list), cursor);
            }
                
            return (new <#= resultType #>(start, start), start);
        };

    public static <#= ptype #> Opt(<#= ptype #> parser) =>
        cursor =>
        {
            var (result, next) = parser(cursor);
            if (result is null) return (new <#= resultType #>(cursor, cursor), cursor);
            return (result, next);
        };

    public static <#= ptype #> Delay(Func<<#= ptype #>> delayed) =>
        cursor => delayed()(cursor);

    static System.CodeDom.Compiler.IndentedTextWriter writer = new (Console.Out);

    public static <#= ptype #> Prod(string production, <#= ptype #> parser) =>
        cursor => 
        {
            //writer.WriteLine($"{production} at {cursor.Offset}");
            //writer.Indent++;
            var (result, next) = parser(cursor);
            //var message = result is null ? $"failed" : $"succeeded";
            //writer.WriteLine($"{production} {message}");
            //writer.Indent--;
            if (result is not null && string.IsNullOrEmpty(result.Production)) result.Production = production;
            return (result, next);
        };

    public static <#= ptype #> Ignore(<#= ptype #> parser) =>
        cursor =>
        {
            var (result, next) = parser(cursor);
            if (result is null) return (null, cursor);
            result = new <#= resultType #>(next, next, result.Children) { Production = result.Production };
            return (result, next);
        };

    public static <#= ptype #> Merge(<#= ptype #> parser) =>
        cursor =>
        {
            var (result, next) = parser(cursor);
            if (result is null) return (null, cursor);
            if (!result.Children.Any()) return (result, next);
            result = new <#= resultType #>(result.Children[0].Start, result.Children[^1].Next) { Production = result.Production };
            return (result, next);
        };
}
<#+
}
#>
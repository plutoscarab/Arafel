<#@ output extension=".cs" encoding="utf-8" #>
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.Linq;
using System.Text;
<#
    Parser("Token", "Rune", "new Rune()");
    Parser("TokenTree", "Token", "new Token(Cursor.Empty, Cursor.Empty)");
#>
<#+
void Parser(string resultType, string cursorType, string endValue)
{
    var ctype = (cursorType == "Rune" ? "" : cursorType) + "Cursor";
    var lctype = cursorType.ToLower();
    var ptype = cursorType + "Parser";
#>

public sealed partial record <#= ctype #>(IReadOnlyList<<#= cursorType #>> Source, int Offset, Context Context)
{
    public <#= ctype #>(IList<<#= cursorType #>> source, Context context)
    : this((IReadOnlyList<<#= cursorType #>>)source, 0, context)
    { }

    private <#= ctype #>(<#= ctype #> cursor, int offset)
    : this(cursor.Source, offset, cursor.Context)
    { }

    public bool More => Offset < Source.Count;

    public <#= cursorType #> Current => More ? Source[Offset] : <#= endValue #>;

    public static bool operator >(<#= ctype #> a, <#= ctype #> b) => a.Offset > b.Offset;
    
    public static bool operator <(<#= ctype #> a, <#= ctype #> b) => a.Offset < b.Offset;

    public static int operator -(<#= ctype #> a, <#= ctype #> b) => a.Offset - b.Offset;

    public <#= ctype #> WithOperator(string production, string op)
    {
        return new <#= ctype #>(Source, Offset, Context.WithOperator(production, op));
    }
}

public partial record <#= resultType #>(<#= ctype #> Start, <#= ctype #> Next)
{
    public readonly List<<#= resultType #>> Children = new();

    public string Production = string.Empty;

    public <#= resultType #>(<#= ctype #> start) : this(start, start.Next()) { }

    public <#= resultType #>(<#= ctype #> start, <#= ctype #> next, IEnumerable<<#= resultType #>> children) 
    : this(start, next) 
    { 
        Children = children.ToList(); 
    }

    public IEnumerable<<#= cursorType #>> <#= cursorType #>s()
    {
        var t = Start;

        while (t.More && t.Offset < Next.Offset)
        {
            yield return t.Current;
            t = t.Next();
        }
    }

    public void Dump(TextWriter writer)
    {
        writer.WriteLine($"Line {Start.Line} Col {Start.Col}");
        Dump(writer, string.Empty);
    }

    private void Dump(TextWriter writer, string indent, bool last = true)
    {
        var branch = last ? "└" : "├";
        var prod = Production;
        if (prod != "") prod += ": ";
        var token = Children.Any() ? "" : string.Join("", <#= cursorType #>s().Select(t => t.ToString()));
        writer.WriteLine($"{indent}{branch}─{prod}{token}");
        indent += last ? "  " : "│ ";
        
        foreach (var (child, i) in Children.Select((c, i) => (c, i)))
        {
            child.Dump(writer, indent, i == Children.Count - 1);
        }
    }
}

public delegate (<#= resultType #>? Result, <#= ctype #> Next) <#= ptype #>(<#= ctype #> cursor);

internal sealed class <#= cursorType #>Parsers
{
    public static <#= ptype #> Any =
        cursor => (new <#= resultType #>(cursor), cursor.Next());

    public static <#= ptype #> Expect(Predicate<<#= cursorType #>> predicate) =>
        cursor => predicate(cursor.Current) ? (new <#= resultType #>(cursor), cursor.Next()) : (null, cursor);

    public static <#= ptype #> Expect<T>() =>
        Expect(<#= lctype #> => <#= lctype #> is T);

    public static <#= ptype #> Expect<T>(params string[] choices) =>
        Expect(<#= lctype #> => <#= lctype #> is T && choices.Contains(<#= lctype #>.ToString()));

    public static <#= ptype #> Expect(params <#= cursorType #>[] values) =>
        Expect(<#= lctype #> => values.Contains(<#= lctype #>));

    public static <#= ptype #> Expect(string text) =>
        Expect(t => t.ToString() == text);

    public static <#= ptype #> Operator(string tag) =>
        cursor => cursor.Context.Operators.Get<#= cursorType #>Parser(tag)(cursor);

    public static <#= ptype #> OneOf(params <#= ptype #>[] parsers) =>
        cursor =>
        {
            foreach (var parser in parsers)
            {
                var (result, next) = parser(cursor);
                if (result is not null) return (result, next);
            }

            return (null, cursor);
        };

    private static void Append(List<<#= resultType #>> list, <#= resultType #> result)
    {
        if (result.Next.Offset <= result.Start.Offset)
            return;

        if (result.Production.EndsWith("_"))
            return;

        if (!result.Children.Any() || !string.IsNullOrEmpty(result.Production))
        {
            list.Add(result);
            return;
        }

        list.AddRange(result.Children.Where(r => !r.Production.EndsWith("_")));
    }

    public static <#= ptype #> Seq(params <#= ptype #>[] parsers) =>
        cursor =>
        {
            var start = cursor;
            List<<#= resultType #>> list = new();

            foreach (var parser in parsers)
            {
                var (result, next) = parser(cursor);
                if (result is null) return (null, cursor);
                Append(list, result);
                cursor = next;
            }

            if (list.Count == 1)
                return (list[0], cursor);

            return (new <#= resultType #>(start, cursor, list), cursor);
        };

    public static <#= ptype #> OneOrMore(<#= ptype #> parser) =>
        cursor =>
        {
            var start = cursor;
            List<<#= resultType #>> list = new();
            
            while (cursor.More)
            {
                var (result, next) = parser(cursor);
                if (result is null) break;
                Append(list, result);
                cursor = next;
            }
            
            if (cursor.Offset > start.Offset)
            {
                if (list.Count == 1)
                    return (list[0], cursor);
                    
                return (new <#= resultType #>(start, cursor, list), cursor);
            }
                
            return (null, start);
        };

    public static <#= ptype #> ZeroOrMore(<#= ptype #> parser) =>
        cursor =>
        {
            var start = cursor;
            List<<#= resultType #>> list = new();
            
            while (cursor.More)
            {
                var (result, next) = parser(cursor);
                if (result is null) break;
                Append(list, result);
                cursor = next;
            }
            
            if (cursor.Offset > start.Offset)
            {
                if (list.Count == 1)
                    return (list[0], cursor);
                    
                return (new <#= resultType #>(start, cursor, list), cursor);
            }
                
            return (new <#= resultType #>(start, start), start);
        };

    public static <#= ptype #> Opt(<#= ptype #> parser) =>
        cursor =>
        {
            var (result, next) = parser(cursor);
            if (result is null) return (new <#= resultType #>(cursor, cursor), cursor);
            return (result, next);
        };

    public static <#= ptype #> Delay(Func<<#= ptype #>> delayed) =>
        cursor => delayed()(cursor);

    public static <#= ptype #> Prod(string production, <#= ptype #> parser) =>
        cursor => 
        {
            var (result, next) = parser(cursor);
            if (result is not null && string.IsNullOrEmpty(result.Production)) result.Production = production;
            return (result, next);
        };

    public static <#= ptype #> Ignore(<#= ptype #> parser) =>
        cursor =>
        {
            var (result, next) = parser(cursor);
            if (result is null) return (null, cursor);
            result = new <#= resultType #>(next, next, result.Children) { Production = result.Production };
            return (result, next);
        };

    public static <#= ptype #> Merge(<#= ptype #> parser) =>
        cursor =>
        {
            var (result, next) = parser(cursor);
            if (result is null) return (null, cursor);
            if (!result.Children.Any()) return (result, next);
            result = new <#= resultType #>(result.Children[0].Start, result.Children[^1].Next) { Production = result.Production };
            return (result, next);
        };

    public static <#= ptype #> Not(<#= ptype #> parser) =>
        cursor =>
        {
            var (result, next) = parser(cursor);
            if (result is null) return (new <#= resultType #>(cursor, cursor.Next()), cursor.Next());
            return (null, cursor);
        };
}

public sealed partial class Grammar
{
    public <#= cursorType #>Grammar Get<#= cursorType #>Parsers()
    {
        Console.OutputEncoding = Encoding.Unicode;
        Console.WriteLine();
        Trees.Dump(Console.Out);
        return new <#= cursorType #>Grammar(Trees);
    }
}

public sealed partial class <#= cursorType #>Grammar
{
    public readonly Dictionary<string, <#= ptype #>> Productions;

    public <#= cursorType #>Grammar(Token t)
    {
        Productions = t.Children.ToDictionary(
            p => p.Children[0].ToString(), 
            p => <#= ptype #>s.Prod(p.Children[0].ToString(), Compile(p.Children[1])))
        .ToDictionary(
            p => p.Key,
            p => char.IsUpper(p.Key[0]) ? <#= ptype #>s.Merge(p.Value) : p.Value);
    }

    <#= ptype #> Compile(Token t)
    {
        switch (t.Production)
        {
            case "seq":
                return <#= ptype #>s.Seq(t.Children.Select(Compile).ToArray());

            case "expr":
                return <#= ptype #>s.OneOf(t.Children.Select(Compile).ToArray());

            case "quoted":
                return <#= ptype #>s.Expect(to => to.ToString() == t.Text);

            case "id":
                if (t.Text != t.Text.ToUpperInvariant())
                    return <#= ptype #>s.Delay(() => Productions[t.ToString()]);
 
                if (<#= cursorType #>s.Lookup.TryGetValue(t.Text, out var parser))
                    return parser;

                return cursor => cursor.Context.Operators.Get<#= cursorType #>Parser(t.Text)(cursor);

            case "atom":
                var expr = Compile(t.Children[0]);

                if (t.Children.Count == 2)
                {
                    var modifier = t.Children[1].ToString();

                    switch (modifier)
                    {
                        case "?": return <#= ptype #>s.Opt(expr);
                        case "*": return <#= ptype #>s.ZeroOrMore(expr);
                        case "+": return <#= ptype #>s.OneOrMore(expr);
                        default: throw new NotImplementedException();
                    }
                }

                return expr;

            case "charCode":
                return CompileCharCode(t);

            case "charOrCode":
                return CompileCharOrCode(t);

            case "charSet":
                return CompileCharSet(t);
        }

        throw new NotImplementedException();
    }

    static <#= ptype #> CompileCharCode(Token t)
    {
        var cp = int.Parse(t.ToString(), System.Globalization.NumberStyles.HexNumber);
        return <#= ptype #>s.Expect(r => r.ToString() == char.ConvertFromUtf32(cp));
    }

    static int GetCharOrCode(Token t)
    {
        if (t.Production == "charCode")
            return int.Parse(t.ToString(), System.Globalization.NumberStyles.HexNumber);

        return char.ConvertToUtf32(t.ToString(), 0);
    }

    static <#= ptype #> CompileCharOrCode(Token t)
    {
        return <#= ptype #>s.Expect(r => r.ToString() == char.ConvertFromUtf32(GetCharOrCode(t)));
    }

    static <#= ptype #> CompileRange(Token t)
    {
        var start = GetCharOrCode(t.Children[0]);
        var end = GetCharOrCode(t.Children[1]);

        return <#= ptype #>s.Expect(r => {
            var cp = char.ConvertToUtf32(r.ToString(), 0);
            return cp >= start && cp <= end;
        });
    }

    static <#= ptype #> CompileCodeOrRange(Token t)
    {
        if (t.Production == "charCode")
            return CompileCharCode(t);

        if (t.Children.Any())
            return CompileRange(t);

        return <#= ptype #>s.Expect(r => r.ToString() == t.ToString());
    }

    static <#= ptype #> CompileCharSet(Token t)
    {
        var neg = t.Children[0].ToString() == "^";
        var chars = t.Children.Skip(neg ? 1 : 0).Select(CompileCodeOrRange).ToArray();
        var p = chars.Length == 1 ? chars[0] : <#= ptype #>s.OneOf(chars);
        if (neg) p = <#= ptype #>s.Not(p);
        return p;
    }
}

public sealed partial class Operators
{
    public <#= cursorType #>Parser Get<#= cursorType #>Parser(string id) =>
        cursor =>
        {
            if (lookup[id].Contains(cursor.Current.ToString()))
                return (new <#= resultType #>(cursor), cursor.Next());

            return (null, cursor);
        };
}
<#+
}
#>
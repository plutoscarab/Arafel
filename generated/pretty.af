
    0
    
    500
    
    1000000
    
    43252003274489856000
    
    2022
    
    64
    
    *(*(365, 24), *(60, 60))
    
    **(5, **(4, **(3, 2)))
    
    +(3², 4²)
    
    105¹²
    
    let x₁ =
        99
    
    let y፳ =
        79
    
    let square(x) =
        *(x, x)
    
    *(*(365, 24), square(60))
    
    let hypot(a, b) =
        sqrt(+(square(a), square(b)))
    
    hypot(3, 4)
    
    type Tree(t) = Leaf(t) | Node(Tree(t), Tree(t))
    
    let x =
        Node(Leaf(a), Node(Leaf(b), Leaf(c)))
    
    let count(t) =
        case t of
            Leaf(_):
                1
            Node(left, right):
                +(count(left), count(right))
    
    count(x)
    
    type List(a) = Nil | Cons(a, List(a))
    
    Nil
    
    Cons(1, Nil)
    
    Cons(1, Cons(2, Cons(3, Nil)))
    
    let natsFromWithSkip(n, skip) =
        Cons(n, natsFromWithSkip(+(n, skip), skip))
    
    let allNatsFrom(n) =
        natsFromWithSkip(n, 1)
    
    let allNats =
        allNatsFrom(0)
    
    type Maybe(a) = Nothing | Just(a)
    
    let head(list) =
        case list of
            Cons(a, _):
                Just(a)
            else
                Nothing
    
    let takeWhile(pred, list) =
        case list of
            Nil:
                Nil
            Cons(head, tail):
                if
                    pred(head)
                    then Cons(head, takeWhile(pred, tail))
                    else Nil
    
    takeWhile((n) = <(n, 100), natsFromWithSkip(5, 2))
    
    let foldl(op, zero, list) =
        case list of
            Nil:
                zero
            Cons(x, rest):
                foldl(op, op(zero, x), rest)
    
    let foldr(op, zero, list) =
        case list of
            Nil:
                zero
            Cons(x, rest):
                op(x, foldr(op, zero, rest))
    
    let all2nds(list) =
        case list of
            Nil:
                Nil
            Cons(Pair(_, b), rest):
                Cons(b, all2nds(rest))
    
    all2nds(Cons(Pair(2, 4), Cons(Pair(3, 9), Nil)))
    
    let map(func, list) =
        case list of
            Nil:
                Nil
            Cons(head, tail):
                Cons(func(head), map(func, tail))
    
    let natsFromTo(from, to) =
        if
            >(from, to)
            then Nil
            else Cons(from, natsFromTo(+(from, 1), to))
    
    map(square, natsFromTo(1, 5))
    
    map((x) = x², natsFromTo(1, 5))
    
    let 😀(list1, list2) =
        case list1 of
            Nil:
                list2
            Cons(head, tail):
                Cons(head, 😀(tail, list2))
    
    😀(Cons(1, Cons(2, Nil)), Cons(3, Cons(4, Cons(5, Nil))))

program ::= (assignment | typeDef | customop | function | expr)+

assignment ::= 'let' pattern '=' expr

expr ::= function* op1
op1 ::= op2 (OP1 op2)*
op2 ::= op3 (OP2 op3)*
op3 ::= op4 (OP3 op4)*
op4 ::= op5 (OP4 op5)*
op5 ::= op6 (OP5 op6)*
op6 ::= op7 (OP6 op7)*
op7 ::= op8 (OP7 op8)*
op8 ::= op9 (OP8 op9)*
op9 ::= op10 (OP9 op10)*
op10 ::= op11 (OP10 op11)*
op11 ::= op12 (OP11 op12)* 
op12 ::= unary (OP12 unary)*
unary ::= PREFIX* atom (SUPER | POSTFIX)*
atom ::= LITERAL | ifthen | exfix | lambda | parens | call | ID | list | array | match

ifthen ::= 'if' expr 'then' expr 'else' expr

parens ::= '(' expr (',' expr)* ')'
exfix ::= '`' ( OPERATOR expr? | expr OPERATOR ) '`'

call ::= ID '(' expr (',' expr)* ')'

list ::= '[' ((expr (',' expr)?)? '..' expr? | expr (',' expr)*)? ']'
array ::= '{' (expr (',' expr)*)? '}'

match ::= 'case' expr 'of' ((pattern | LITERAL | '-'? NAT) '->' expr)+ ('else' '->' expr)?
pattern ::= listPattern | tuplePattern | arrayPattern | ctorPattern
ctorPattern ::= ID ids?
ids ::= '(' ID (',' ID)* ')'
listPattern ::= (ID ':')+ (ID | '[' ']') | '[' ']'
tuplePattern ::= ID (',' ID)+

arrayPattern ::= '{' ((ID (',' (ID ',')* '..')? | '..' ',' ID) (',' ID)*)? '}'

function ::= ID ids '=' expr
lambda ::= ids '=' expr
customop ::= 'op' (infix | prefix | postfix) '=' expr
infix ::= '-'? NAT ID (OPERATOR | ID) ID
prefix ::= OPERATOR ID
postfix ::= ID OPERATOR

typeDef ::= 'type' ID ids? '=' (unionDef | tupleDef)
unionDef ::= typeName ('|' typeName)+
tupleDef ::= typeName ('*' typeName)+
typeName ::= ID ('(' typeName (',' typeName)* ')')?

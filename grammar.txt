program ::= (assignment | typeDef | function | infix | expr)+

assignment ::= 'let' pattern '=' expr

expr ::= ('if' or 'then' or ('else' or)?) | or
or ::= xor ('|' xor)*
xor ::= and ('^' and)*
and ::= eq ('&' eq)*
eq ::= compare (('==' | '!=' | '≠') compare)*
compare ::= threeWay (('<' | '<=' | '≤' | '>' | '>=' | '≥') threeWay)*
threeWay ::= cons ('<=>' cons)*
cons ::= sum ((':' | '++') sum)*
sum ::= shift (('+' | '-') shift)*
shift ::= term (('<<' | '>>') term)*
term ::= atIndex (('*' | '/' | './' | '%') atIndex)*
atIndex ::= power ('!!' power)*
power ::= unary ('**' unary)*
unary ::= ('+' | '-' | '~' | '√' | '∛' | '∜')* atom SUPER?
atom ::= CHAR | STRING | BOOL | DECIMAL | NAT | parens | exfix | call | list | array | match | ID | 'π'

parens ::= '(' expr (',' expr)* ')'
exfix ::= '`' ( OPERATOR expr? | expr OPERATOR ) '`'

call ::= ID '(' expr (',' expr)* ')'

list ::= '[' ((expr (',' expr)?)? '..' expr? | expr (',' expr)*)? ']'
array ::= '{' (expr (',' expr)*)? '}'

match ::= 'case' expr 'of' ((pattern | CHAR | STRING | BOOL | DECIMAL | '-'? NAT) '->' expr)+ ('else' '->' expr)?
pattern ::= listPattern | tuplePattern | arrayPattern | ctorPattern
ctorPattern ::= ID ids?
ids ::= '(' ID (',' ID)* ')'
listPattern ::= (ID ':')+ (ID | '[]') | '[]'
tuplePattern ::= ID (',' ID)+

arrayPattern ::= '{' ((ID (',' (ID ',')* '..')? | '..' ',' ID) (',' ID)*)? '}'

function ::= 'fn' ID ids '=' expr
infix ::= ('infixl' | 'infixr') NAT ID (OPERATOR | ID) ID NAT? '=' expr

typeDef ::= 'type' ID ids? '=' (unionDef | tupleDef)
unionDef ::= typeName ('|' typeName)+
tupleDef ::= typeName ('*' typeName)+
typeName ::= ID ('(' typeName (',' typeName)* ')')?
